Figure~\ref{fig:hash_flowchart} presents the flowchart of the
\texttt{crypto\_hashblocks()} function.

\begin{figure}[!htbp]
    \centerline{\includegraphics[width=14cm]{./figures/crypto_hashblock_flowchart.pdf}}
    \vspace{0cm}\caption{\texttt{crypto\_hashblocks()} function flowchart.}
    \label{fig:hash_flowchart}
\end{figure}

The function starts by reading the current state from memory. Then each block
of 64 bytes (256 bits) of the input data is used as input to the main hash
block.
After all input data is used, the new state is written to memory.
The majority of computations take place in the main hash block inside the loop.

Figure~\ref{fig:main_hashblock_diagram} presents a diagram for the main hash
block.

\begin{figure}[!htbp]
    \centerline{\includegraphics[width=18cm]{./figures/main_hashblock_diagram.pdf}}
    \vspace{0cm}\caption{Main hash block diagram.}
    \label{fig:main_hashblock_diagram}
\end{figure}

The main hash block output is the accumulation from the initial state with the
new computed state.
The new computed state is the output of the sequence of \textbf{F} blocks. Each
\textbf{F} block receives three inputs: a set of constants stored in the
\textbf{cMem} blocks; the previous or initial state in the \textbf{a-h}
variables; and a set of words from the message scheduling array \textbf{w}.

Each set of 16 \textbf{w} words is obtained from the input data or by applying a
previous set of words to the \textbf{M} block.

The proposed accelerator architecture has 5 functional unit (FU) types:
\begin{itemize}
    \item 1 Vread to store the input data;
    \item 1 State FU to store and accumulate the \textbf{a-h} state variables;
    \item 3 Memories to store the constants (equivalent to \textbf{cMem}
        blocks);
    \item 3 \textbf{M} FUs that generate a new set of message schedule array
        words;
    \item 4 \textbf{F} FUs that perform the compression function.
\end{itemize}

The Vread, state and memory FUs are default FUs from Versat. The \textbf{M} and
\textbf{F} FUs are custom units built specifically for the SHA256 application.

The \textbf{M} FU performs the logic equivalent to the \texttt{EXPAND\_32}
macro presented in Listing~\ref{lst:expand_macro}. The macro generates 16 new
words for the message schedule array. Each new word is generated by applying
logic operations to previous words.

\begin{lstlisting}[language=C,caption={\texttt{EXPAND\_32} macro.},
label={lst:expand_macro}]

    #define SHR(x, c) ((x) >> (c))
    #define ROTR_32(x, c) (((x) >> (c)) | ((x) << (32 - (c))))
    #define ROTR_64(x, c) (((x) >> (c)) | ((x) << (64 - (c))))

    #define sigma0_32(x) (ROTR_32(x, 7) ^ ROTR_32(x,18) ^ SHR(x, 3))
    #define sigma1_32(x) (ROTR_32(x,17) ^ ROTR_32(x,19) ^ SHR(x,10))

    #define M_32(w0, w14, w9, w1) w0 = sigma1_32(w14) + (w9) + sigma0_32(w1) + (w0);

    #define EXPAND_32           \
        M_32(w0, w14, w9, w1)   \
        M_32(w1, w15, w10, w2)  \
        M_32(w2, w0, w11, w3)   \
        M_32(w3, w1, w12, w4)   \
        M_32(w4, w2, w13, w5)   \
        M_32(w5, w3, w14, w6)   \
        M_32(w6, w4, w15, w7)   \
        M_32(w7, w5, w0, w8)    \
        M_32(w8, w6, w1, w9)    \
        M_32(w9, w7, w2, w10)   \
        M_32(w10, w8, w3, w11)  \
        M_32(w11, w9, w4, w12)  \
        M_32(w12, w10, w5, w13) \
        M_32(w13, w11, w6, w14) \
        M_32(w14, w12, w7, w15) \
        M_32(w15, w13, w8, w0)

\end{lstlisting}

The \textbf{F} FU performs the logic equivalent to a group of 16
\texttt{F\_32(w,k)} macros which are presented in Listing~\ref{lst:F32_macro}.
Each \texttt{F\_32(w,k)} macro updates the state values (\textbf{a} to
\textbf{h}) using one message schedule word, one constant value and the
previous state values.

\begin{lstlisting}[language=C,caption={Group of 16 \texttt{F\_32(w,k)} macros.},
label={lst:F32_macro}]

    #define Ch(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
    #define Maj(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

    #define Sigma0_32(x) (ROTR_32(x, 2) ^ ROTR_32(x,13) ^ ROTR_32(x,22))
    #define Sigma1_32(x) (ROTR_32(x, 6) ^ ROTR_32(x,11) ^ ROTR_32(x,25))

    #define F_32(w, k)                                   \
        T1 = h + Sigma1_32(e) + Ch(e, f, g) + (k) + (w); \
        T2 = Sigma0_32(a) + Maj(a, b, c);                \
        h = g;                                           \
        g = f;                                           \
        f = e;                                           \
        e = d + T1;                                      \
        d = c;                                           \
        c = b;                                           \
        b = a;                                           \
        a = T1 + T2;


    F_32(w0, const0)
    F_32(w1, const1)
    F_32(w2, const2)
    F_32(w3, const3)
    F_32(w4, const4)
    F_32(w5, const5)
    F_32(w6, const6)
    F_32(w7, const7)
    F_32(w8, const8)
    F_32(w9, const9)
    F_32(w10, const10)
    F_32(w11, const11)
    F_32(w12, const12)
    F_32(w13, const13)
    F_32(w14, const14)
    F_32(w15, const15)

\end{lstlisting}

